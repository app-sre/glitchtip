diff --git a/glitchtip/settings.py b/glitchtip/settings.py
index 59c46d2..8a4af9a 100644
--- a/glitchtip/settings.py
+++ b/glitchtip/settings.py
@@ -421,6 +421,10 @@ CELERY_BEAT_SCHEDULE = {
         "task": "glitchtip.uptime.tasks.dispatch_checks",
         "schedule": timedelta(seconds=30),
     },
+    "relate-users": {
+        "task": "organizations_ext.tasks.relate_users",
+        "schedule": timedelta(minutes=1),
+    },
 }
 
 
diff --git a/glitchtip/social.py b/glitchtip/social.py
index c4ef995..e2f454b 100644
--- a/glitchtip/social.py
+++ b/glitchtip/social.py
@@ -142,24 +142,8 @@ class SocialLoginSerializer(BaseSocialLoginSerializer):
             raise serializers.ValidationError(ret.content)
 
         if not login.is_existing:
-            if allauth_settings.UNIQUE_EMAIL:
-                account_exists = (
-                    get_user_model()
-                    .objects.filter(
-                        email=login.user.email,
-                    )
-                    .exists()
-                )
-                if account_exists:
-                    raise serializers.ValidationError(
-                        _("User is already registered with this e-mail address."),
-                    )
-            # Added check for open signup
-            if not get_adapter(request).is_open_for_signup(request, login):
-                raise serializers.ValidationError(_("User registration is closed."))
-            else:
-                login.lookup()
-                login.save(request, connect=True)
+            login.lookup()
+            login.save(request, connect=True)
 
         attrs["user"] = login.account.user
 
diff --git a/organizations_ext/tasks.py b/organizations_ext/tasks.py
index 666f1d5..e6cedaa 100644
--- a/organizations_ext/tasks.py
+++ b/organizations_ext/tasks.py
@@ -46,3 +46,20 @@ def send_email_met_quota(organization_id: int):
 @shared_task
 def send_email_invite(org_user_id: int, token: str):
     InvitationEmail(pk=org_user_id, token=token).send_email()
+
+
+@shared_task
+def relate_users():
+    """Create missing django users for all org users and accept the invite manually."""
+    from django.contrib.auth import get_user_model
+
+    from .models import OrganizationUser
+
+    User = get_user_model()
+    for org_user in OrganizationUser.objects.filter(user=None):
+        user, created = User.objects.get_or_create(
+            email=org_user.email,
+        )
+        if created:
+            user.set_unusable_password()
+        org_user.accept_invite(user)
